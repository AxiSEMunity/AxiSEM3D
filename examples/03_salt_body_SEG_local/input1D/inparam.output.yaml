#
#  inparam.output.yaml
#  AxiSEM3D
#
#  Created by Kuangdai Leng on 6/20/20.
#  Copyright © 2020 Kuangdai Leng. All rights reserved.
#

#  This is an AxiSEM3D input parameter file for
#  station-wise and element-wise output


############################# station-wise #############################
# what: list of station groups
# type: array of objects
# note: 1) different options such as channels and sampling rates can
#          be used for different station groups; for example, one may
#          have one group of real-world seismic stations to record the
#          displacement vector at a high sampling rate and another group
#          of animation stations to record only the vertical displacement
#          at a low sampling rate
#       2) use [] if no station group presents
list_of_station_groups: []


############################# element-wise #############################
# what: list of element groups
# type: array of objects
# note: 1) different options such as channels and sampling rates can
#          be used for different element groups
#       2) use [] if no element group presents
list_of_element_groups:
    #==========================================================================#
    # this key can be arbitrary but must be unique in this list
    - orthogonal_azimuthal_slices:
        # elements to be recorded
        # note: an element will be included if its center falls within
        #       both horizontal_range and vertical_range
        elements:
            # what: horizontal range
            # type: array of double
            # note: 1) θ-range for a spherical mesh
            #       2) s-range for a Cartesian mesh
            horizontal_range: [0, 1e10]
            # what: vertical range
            # type: array of double
            # note: 1) r-range for a spherical mesh
            #       2) z-range for a Cartesian mesh
            vertical_range: [0, 1e10]
        # inplane sampling on each element
        inplane:
            # what: edge dimension
            # type: string
            # only: HORIZONTAL / VERTICAL / BOTH
            # note: 1) use HORIZONTAL or VERTICAL to record only an outer edge
            #          of each element, with the edge position specified below
            #       2) use BOTH to record the entire element
            edge_dimension: BOTH
            # what: edge position
            # type: double
            # note: 1) as we only search among the four outer edges of each
            #          element, this edge position must lie on a mesh
            #          boundary (either internal or external), such as one
            #          of the vertical discontinuities
            #       2) not used if edge_dimension = BOTH
            edge_position: 6371e3
            # what: GLL points on one edge
            # type: string / array of int
            # only: FULL / a subset of [0, 1, 2, ..., npol], where npol is
            #       the polynomial order of spectral elements, given in
            #       CMakeLists.txt
            # note: use this parameter for inplane downsampling;
            #       for example, when npol = 4:
            #       - [2]:       only the element center
            #       - [0, 4]:    only the 4 vertices
            #       - [0, 2, 4]: 4 vertices + 4 edge centers + 1 element center
            #       - FULL:      all GLL points, the same as [0, 1, 2, 3, 4]
            GLL_points_one_edge: [0, 2, 4]
        # azimuthal sampling on each element
        # note: if both phi_list and lat_lon_list are empty, no azimuthal
        #       interpolation will be performed; instead, all the Fourier
        #       series coefficients at each GLL point will be recorded
        azimuthal:
            # what: azimuths (ɸ) of the recorded slices
            # type: array of double
            # note: the unit is radian
            phi_list: [0, 1.57079632679, 3.14159265359, 4.71238898038]
            # what: latitudes and longitudes of the recorded slices
            # type: array of array of double
            # note: ɸ computed from (lat, lon) will be append to phi_list
            lat_lon_list: []
            # what: grid space for azimuthal storage
            # type: int
            # note: 1) when the Fourier series coefficients are recorded
            #          (phi_list = [] and lat_lon_list = []), this parameter
            #          affects how the wavefield data with different azimuthal
            #          dimensions are stored in the output NetCDF file(s);
            #          see the online manual for details
            #       2) must be greater than or equal to 1
            #       3) recommended: maximum Nr in the target region / 200
            na_space: 1
        # wavefields to be recorded
        wavefields:
            # what: coordinate frame of wavefields
            # type: string
            # only: spz / RTZ / ENZ
            # note: 1) spz: (s, phi, z) or AxiSEM3D-intrinsic
            #       2) RTZ: (radial, transpose, vertical)
            #       3) ENZ: (east, north, vertical)
            coordinate_frame: RTZ
            # what: type of medium
            # type: string
            # only: SOLID / FLUID
            # note: all elements in a group must be located in either
            #       the solid or the fluid domain
            medium: SOLID
            # what: list of channels
            # type: array of string
            # note: 1) allowed channels for medium = SOLID
            #          * displacement:
            #            U, U1, U2, U3, U_NORM (or |U|)
            #          * gradient of displacement:
            #            G, G11, G12, G13, G21, G22, G23, G31, G32, G33,
            #            Gii (or G_I1)
            #          * strain:
            #            E, E11, E12, E13, E21, E22, E23, E31, E32, E33,
            #            Eii (or E_I1), E_J2
            #          * stress:
            #            S, S11, S12, S13, S21, S22, S23, S31, S32, S33,
            #            Sii (or S_I1), S_J2
            #          * curl:
            #            R, R1, R2, R3, R_NORM (or |R|)
            #      2) allowed channels for medium = FLUID
            #          * displacement:
            #            U, U1, U2, U3, U_NORM (or |U|)
            #          * scalar potential of displacement (U = ∇X):
            #            X
            #          * pressure:
            #            P
            #      3) (1, 2, 3) are determined by coordinate_frame
            #      4) using U means [U1, U2, U3], and similarly for G, E, S
            #         and R; duplicated channels are automatically removed
            channels: [U]
        # temporal sampling
        temporal:
            # what: sampling period
            # type: string / double
            # only: DT / DTx2 / DTx3 / ... / value
            # note: DT stands for Δt of the simulation; DTx3 means
            #       sampling period = Δt * 3
            sampling_period: 0.05
            # what: time window
            # type: string / array of double
            # only: FULL / [t0, t1]
            # note: use FULL to record the whole simulation
            time_window: FULL
        # file options
        file_options:
            # what: number of sampled time steps to be buffered
            # type: int
            # note: 1) the solver buffers wave data during the time loop for
            #          efficient writing; increase this buffer size to save
            #          writing time and decrease it to save memroy (useful for
            #          a large number of stations)
            #       2) this parameter does not affect the final results
            buffer_size: 1000
            # what: flush file after writing a buffer to it
            # type: bool
            # note: 1) pro: minimizes data loss in case of abnormal termination
            #          con: hits output performace if buffer_size is small
            #       2) this parameter does not affect the final results
            flush: true
    #==========================================================================#
    # this key can be arbitrary but must be unique in this list
    - Fourier_coefficients_ocean_floor:
        # elements to be recorded
        # note: an element will be included if its center falls within
        #       both horizontal_range and vertical_range
        elements:
            # what: horizontal range
            # type: array of double
            # note: 1) θ-range for a spherical mesh
            #       2) s-range for a Cartesian mesh
            horizontal_range: [0, 1e10]
            # what: vertical range
            # type: array of double
            # note: 1) r-range for a spherical mesh
            #       2) z-range for a Cartesian mesh
            vertical_range: [0, 1e10]
        # inplane sampling on each element
        inplane:
            # what: edge dimension
            # type: string
            # only: HORIZONTAL / VERTICAL / BOTH
            # note: 1) use HORIZONTAL or VERTICAL to record only an outer edge
            #          of each element, with the edge position specified below
            #       2) use BOTH to record the entire element
            edge_dimension: VERTICAL
            # what: edge position
            # type: double
            # note: 1) as we only search among the four outer edges of each
            #          element, this edge position must lie on a mesh
            #          boundary (either internal or external), such as one
            #          of the vertical discontinuities
            #       2) not used if edge_dimension = BOTH
            edge_position: 6370.8e3
            # what: GLL points on one edge
            # type: string / array of int
            # only: FULL / a subset of [0, 1, 2, ..., npol], where npol is
            #       the polynomial order of spectral elements, given in
            #       CMakeLists.txt
            # note: use this parameter for inplane downsampling;
            #       for example, when npol = 4:
            #       - [2]:       only the element center
            #       - [0, 4]:    only the 4 vertices
            #       - [0, 2, 4]: 4 vertices + 4 edge centers + 1 element center
            #       - FULL:      all GLL points, the same as [0, 1, 2, 3, 4]
            GLL_points_one_edge: FULL
        # azimuthal sampling on each element
        # note: if both phi_list and lat_lon_list are empty, no azimuthal
        #       interpolation will be performed; instead, all the Fourier
        #       series coefficients at each GLL point will be recorded
        azimuthal:
            # what: azimuths (ɸ) of the recorded slices
            # type: array of double
            # note: the unit is radian
            phi_list: []
            # what: latitudes and longitudes of the recorded slices
            # type: array of array of double
            # note: ɸ computed from (lat, lon) will be append to phi_list
            lat_lon_list: []
            # what: grid space for azimuthal storage
            # type: int
            # note: 1) when the Fourier series coefficients are recorded
            #          (phi_list = [] and lat_lon_list = []), this parameter
            #          affects how the wavefield data with different azimuthal
            #          dimensions are stored in the output NetCDF file(s);
            #          see the online manual for details
            #       2) must be greater than or equal to 1
            #       3) recommended: maximum Nr in the target region / 200
            na_space: 1
        # wavefields to be recorded
        wavefields:
            # what: coordinate frame of wavefields
            # type: string
            # only: spz / RTZ / ENZ
            # note: 1) spz: (s, phi, z) or AxiSEM3D-intrinsic
            #       2) RTZ: (radial, transpose, vertical)
            #       3) ENZ: (east, north, vertical)
            coordinate_frame: RTZ
            # what: type of medium
            # type: string
            # only: SOLID / FLUID
            # note: all elements in a group must be located in either
            #       the solid or the fluid domain
            medium: SOLID
            # what: list of channels
            # type: array of string
            # note: 1) allowed channels for medium = SOLID
            #          * displacement:
            #            U, U1, U2, U3, U_NORM (or |U|)
            #          * gradient of displacement:
            #            G, G11, G12, G13, G21, G22, G23, G31, G32, G33,
            #            Gii (or G_I1)
            #          * strain:
            #            E, E11, E12, E13, E21, E22, E23, E31, E32, E33,
            #            Eii (or E_I1), E_J2
            #          * stress:
            #            S, S11, S12, S13, S21, S22, S23, S31, S32, S33,
            #            Sii (or S_I1), S_J2
            #          * curl:
            #            R, R1, R2, R3, R_NORM (or |R|)
            #      2) allowed channels for medium = FLUID
            #          * displacement:
            #            U, U1, U2, U3, U_NORM (or |U|)
            #          * scalar potential of displacement (U = ∇X):
            #            X
            #          * pressure:
            #            P
            #      3) (1, 2, 3) are determined by coordinate_frame
            #      4) using U means [U1, U2, U3], and similarly for G, E, S
            #         and R; duplicated channels are automatically removed
            channels: [U]
        # temporal sampling
        temporal:
            # what: sampling period
            # type: string / double
            # only: DT / DTx2 / DTx3 / ... / value
            # note: DT stands for Δt of the simulation; DTx3 means
            #       sampling period = Δt * 3
            sampling_period: 0.01
            # what: time window
            # type: string / array of double
            # only: FULL / [t0, t1]
            # note: use FULL to record the whole simulation
            time_window: FULL
        # file options
        file_options:
            # what: number of sampled time steps to be buffered
            # type: int
            # note: 1) the solver buffers wave data during the time loop for
            #          efficient writing; increase this buffer size to save
            #          writing time and decrease it to save memroy (useful for
            #          a large number of stations)
            #       2) this parameter does not affect the final results
            buffer_size: 1000
            # what: flush file after writing a buffer to it
            # type: bool
            # note: 1) pro: minimizes data loss in case of abnormal termination
            #          con: hits output performace if buffer_size is small
            #       2) this parameter does not affect the final results
            flush: true
